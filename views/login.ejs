<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>ESUP-OTP</title>
    <link rel="stylesheet" type="text/css" href="cas.css">
</head>

<body>
    <header role="banner" id="headerEcranConnexion">
        <script> window.bandeau_anonyme = {}; </script>
        <script src="https://ent-test.univ-paris1.fr/assets/bandeau-anonyme/loader.js"></script>
        <div><h1>Authentification renforcée</h1></div>
    </header>

    <main role="main">
    <div id="content" class="main">

      <form method="post" id="fm1">
        <input id="ticket" name="ticket" value="<%= ticket %>" type="hidden">

       <div id="errors">
          <%= error %>
       </div>

       <div class="main1">

        <div id="no-choices" class="d-none">
            Vous n'avez pas activé vos codes à usage unique.
            <br/><br/>
            Nous vous invitons à activer l'authentification renforcée sur l'application de
            <a href="https://otpmanager-test.univ-paris1.fr/preferences" target="_blank">gestion d'authentification</a> de votre compte.
        </div>

        <div id="choices">
            <h2>
            <b>Générez un code à usage unique</b>
            <br>par une des méthodes suivantes pour vous connecter
            </h2>

            <ul id="methodChoices">
                <li>Veuillez patienter</li>
            </ul>

            Un problème ? <a href="mailto:assistance-dsiun@univ-paris1.fr?subject=Problème ESUP-OTP">Contactez la DSIUN</a>
        </div>
               
        <div id="code" class="d-none">
          <div>                                             
            <label for="token">
                <div id="code_label"></div>
                <input type="text" id="token" tabindex="1" required
                oninput="autosubmitIfValid(this)"
                minlength="6" maxlength="6" pattern="[0-9]{6}"
                placeholder="Saisissez le code de 6 chiffres"
                accesskey="m" autocomplete="off" name="token" value="">
            </label>

            <ul>      
                <li id="resend"><a></a></li>
                <li id="back_to_choices"><a onclick="clear_errors(); show('choices')">Autre méthode de connexion</a></li>
                <li>Un problème ? <a href="mailto:assistance-dsiun@univ-paris1.fr?subject=Problème ESUP-OTP">Contactez la DSIUN</a></li>
            </ul>
          </div>
          <img id="page_icon"></div>        
       </div>

       <div id="webauthn" class="d-none">
            <input type="hidden" id="wa_token" required autocomplete="off" name="token" value="">

            <header>
                <p id="title" class="title nomargin"></p>
                <p class="desc nomargin">
                    <span id="subtitle" class="subtitle desc nomargin"></span>
                    <a id="ask-reload" class="nomargin subtle underlined" onclick="window.location.reload();" style="display: none;">Réessayer</a>
                </p>
            </header>


            <p id="extended-desc" style="display: none;"></p>
            <p id="authenticators-list" style="display: none;"></p>

            <ul class="help-links">
                <li id="try-another-method"><a onclick="clear_errors(); cleanup_webauthn(); show('choices')">Autre méthode de connexion</a></li>
                <li>Un problème ? <a href="mailto:assistance-dsiun@univ-paris1.fr?subject=Problème ESUP-OTP">Contactez la DSIUN</a></li>
            </ul>
       </div>
      </form>                        
    </div>
    </main>
        
<script src="javascripts/jquery.min.js"></script>
<script src="<%= params.apiUrl %>/js/socket.io.js" async></script>
<script>

    // for IE11 in pulse-secure
    Array.prototype.find = Array.prototype.find || function(callback) {
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        for (var i = 0; i < length; i++) {
            var element = list[i];
            if ( callback.call(thisArg, element, i, list) ) {
                return element;
            }
        }
    };


    /** base64url helper functions **/
    /**
    * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a
    * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or
    * excludeCredentials
    *
    * Helper method to compliment `bufferToBase64URLString`
    */
    function base64URLStringToBuffer(base64URLString) {
        // Convert from Base64URL to Base64
        const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');
        /**
         * Pad with '=' until it's a multiple of four
         * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding
         * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding
         * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding
         * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding
         */
        const padLength = (4 - (base64.length % 4)) % 4;
        const padded = base64.padEnd(base64.length + padLength, '=');

        // Convert to a binary string
        const binary = atob(padded);

        // Convert binary string to buffer
        const buffer = new ArrayBuffer(binary.length);
        const bytes = new Uint8Array(buffer);

        for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
        }

        return buffer;
    }

    /**
    * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various
    * credential response ArrayBuffers to string for sending back to the server as JSON.
    *
    * Helper method to compliment `base64URLStringToBuffer`
    * 
    * source: https://github.com/MasterKale/SimpleWebAuthn/blob/master/packages/browser/src/helpers/bufferToBase64URLString.ts
    */
    function bufferToBase64URLString(buffer) {
        const bytes = new Uint8Array(buffer);
        let str = '';

        for (const charCode of bytes) {
            str += String.fromCharCode(charCode);
        }

        const base64String = btoa(str);

        return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }


    function autosubmitIfValid(input) {
        if (!input.validationMessage) {
            document.getElementById("fm1").submit()
        }
    }

    function clear_errors() {
        $("#errors").remove();
    }

    function show(idToShow) {
        ["no-choices", "choices", "code", "webauthn"].forEach(function (id) {
            $('#' + id).toggleClass('d-none', id !== idToShow);
        });
    }
    function show_method(params, chosen) {
        show('code');

        $("#token, #submitCode").toggleClass('d-none', chosen.method === 'push');
        $("#token").focus();
        var methods = chosen.real_methods.sort().join(' ')
        $("#code_label").html(
            methods === 'totp' ?
                "Merci de renseigner le code affiché sur votre application TOTP :" :
            methods === 'bypass totp' ?
                "Merci de renseigner le code affiché sur votre application TOTP ou un code de secours :" :
                "Merci de renseigner un code :"
        );

        document.querySelector('#page_icon').src = 'images/page-' + (chosen.transport || chosen.method) + ".svg"

        $("#back_to_choices").toggleClass('d-none', $("#methodChoices > li").length <= 1)

        $("#resend").toggleClass('d-none', !chosen.transport)
        document.querySelector("#resend a").text = chosen.transport === 'push' ? "Demander une nouvelle notification" : "Recevoir un nouveau code"
        document.querySelector("#resend a").onclick = function () { clear_errors(); activate_method(params, chosen, {}) }

        return false;
    }

    function getUserOtpMethods(params) {
        $.ajax({ url: params.apiUrl + '/users/'+ params.uid +'/' + params.userHash }).done(function(data) {
            if (data.code != "Ok") {
                alert("Erreur, veuillez réessayer ultérieurement");
                return;
            }
            displayChoices(params, data.user);
        });
    }
    var methods = {
        // l'ordre est utilisé pour choisir dans quel ordre afficher les méthodes
        webauthn: {
            label: {
                '': "S'authentifier par facteur physique"
            },
            override_icon: 'cle'
        },
        push: { label: { 
            push: "S'authentifier sur %TRANSPORT%",
        } },
        no_transport: { real_methods: [ 'totp', 'bypass'], label: {
            '': 'Saisir un code TOTP ou un code de secours',
        } },
        random_code: { label: { 
            sms: "Recevoir un code par SMS sur %TRANSPORT%",
            mail: "Recevoir un code par mél sur %TRANSPORT%",
        } },
    }

    function activate_method(params, chosen, opts) {
        if(chosen.method === 'webauthn') {
            showWebauthnMethod(params);
            return;
        }
        if (chosen.method === 'push') {
            initializeSocket(params);
        }
        if (chosen.transport) {
            submitCodeRequest(params, chosen, opts);
        }
        show_method(params, chosen);
    }

    function toggleDisplay(element, shown) {
        const value_hidden = 'none';
        // value you gave (e.g. 'flex') or nothing (reset)
        const value_shown = element.initialDisplayProperty ?? '';  

        if(!shown && value_shown === '' && element.initialDisplayProperty === undefined) {
            element.initialDisplayProperty = element.style.display;
        }
        element.style.display = shown ? value_shown : value_hidden;
    }

    function cleanup_webauthn() {
        const title = document.querySelector("#webauthn #title");
        const subtitle = document.querySelector("#webauthn #subtitle");
        const extended_desc = document.querySelector("#webauthn #extended-desc");
        const auths_list = document.querySelector("#webauthn #authenticators-list");
        const try_another_method = document.querySelector("#webauthn #try-another-method");

        title.textContent = "";
        subtitle.textContent = "";

        // remove the description
        extended_desc.textContent = "";
        toggleDisplay(extended_desc, false);

        toggleDisplay(try_another_method, true);

        // remove all options
        while(auths_list.lastChild) {
            auths_list.lastChild.remove();
        }
    }

    function showWebauthnMethod(params) {
        

        // PublicKeyCredential can not be serialized
		// because it contains some ArrayBuffers, which
		// can not be serialized.
		// This just translates the buffer to its' 'safe'
		// version.
        // This is only for the AUTHENTICATION part
        // It is slightly different from what is
        // used for registration
		const SerializePKC = PKC => {
			return {
				id: PKC.id,
				type: PKC.type,
				rawId: bufferToBase64URLString(PKC.rawId),
				response: {
					authenticatorData: bufferToBase64URLString(PKC.response.authenticatorData),
					clientDataJSON: bufferToBase64URLString(PKC.response.clientDataJSON),
					signature: bufferToBase64URLString(PKC.response.signature),
					userHandle: PKC.response.userHandle ? bufferToBase64URLString(PKC.response.userHandle) : undefined,
				}
			};
		}

    
        fetch(`${params.apiUrl}users/${params.uid}/webauthn/secret/${params.userHash}`)
        .then(res => res.json())
        .then(async data => {
            show('webauthn');

            const title = document.querySelector("#webauthn #title");
            const subtitle = document.querySelector("#webauthn #subtitle");
            const ask_reload = document.querySelector("#webauthn #ask-reload");
            const extended_desc = document.querySelector("#webauthn #extended-desc");
            const auths_list = document.querySelector("#webauthn #authenticators-list");
            const try_another_method = document.querySelector("#webauthn #try-another-method");


            /**
             * helper function to write to the text boxes
             * more easily.
             * Accepts an object _opts, with attributes :
             * - 'title' for the main text on the page
             * - 'desc' for the text just below title
             * - 'extended' if you need to write a long message,
             *   a paragraph will be shown in normal font size.
             * - 'show_ask_reload' if the link-button to reload
             *   the page should be shown (false by default)
             * - 'show_try_another' if the link-button to try
             *   another method should be shown (true by default)
             * - '_raw_html' if this is true, the inputs are treated as raw html instead
             *   (false by default)
             */
            const displayText = (_opts) => {
                // set defaults
                const opts = {
                    title: "",
                    desc: "",
                    extended: "",

                    show_ask_reload: false,
                    show_try_another: true,
                    _raw_html: false,

                    ..._opts
                }
                
                const emptyAndAdd = (content, element) => {
                    // empty element
                    while (element.firstChild) element.removeChild(element.firstChild);

                    // does nothing more if content is falsy (like empty string or empty array)
                    if(!content || content.length === 0) {
                        return;
                    }

                    if(opts._raw_html) {
                        // add content
                        element.innerHTML = content;
                        return;
                    }

                    // add content
                    if(Array.isArray(content)) {
                        content.forEach(e => element.append(e));
                    }
                    else {
                        element.append(content);
                    }
                } 

                emptyAndAdd(opts.title, title);
                emptyAndAdd(opts.desc, subtitle);
                emptyAndAdd(opts.extended, extended_desc);

                toggleDisplay(extended_desc, opts.extended !== undefined);
                toggleDisplay(ask_reload, opts.show_ask_reload);
                toggleDisplay(try_another_method, opts.show_try_another);
            }
            
            /**
             * Converts an authenticator object 
             * to a cute span to use
             */
            const authToSpan = (authenticator) => {
                const span = document.createElement("span");
                span.className = "factor";
                if(authenticator.name) {
                    span.textContent = authenticator.name;
                    span.title = `Le facteur physique que vous avez nommé "${authenticator.name}"` 
                }
                else {
                    span.textContent = "clé sans nom";
                    span.title = "Vous n'avez pas donné de nom à ce facteur. Allez dans vos paramètres pour donner un nom."
                }

                const icon = document.createElement("i");
                icon.className = "material-icons";
                icon.textContent = "vpn_key"
                span.prepend(icon);

                return span;
            };

            if(data.auths.length === 0) {
                displayText({
                    title: "Vous n'avez aucun facteur enregistré",
                    desc: "Essayez une autre méthode"
                });
            }
            else if(data.auths.length === 1) {
                displayText({
                    title: ["Utilisez ", authToSpan(data.auths[0]), " pour vous authentifier."],
                })
            }
            else {
                let spans = data.auths.map(authToSpan);

                if(spans.length === 2) {
                    spans = [spans[0], "ou", spans[1]];
                    // => "[] ou []"                    
                }
                // > 2
                else {
                    const temp = [];
                    // all except last
                    spans.slice(0, -1).forEach(span => {
                        temp.push(span, ', ');
                    });
                    // then add last
                    temp.push('ou', spans.slice(-1));

                    // => "[], [], [], ou []"
                    spans = temp;
                }

                displayText({
                    title: ["Utilisez", ...spans, "pour vous authentifier."],
                    show_list: true
                })

            }


            // arguments for the webauthn registration
			const pubkeyTypes = [
				{
				  "type": "public-key",
				  "alg": -7
				},
				{
				  "type": "public-key",
				  "alg": -8
				},
				{
				  "type": "public-key",
				  "alg": -36
				},
				{
				  "type": "public-key",
				  "alg": -37
				},
				{
				  "type": "public-key",
				  "alg": -38
				},
				{
				  "type": "public-key",
				  "alg": -39
				},
				{
				  "type": "public-key",
				  "alg": -257
				},
				{
				  "type": "public-key",
				  "alg": -258
				},
				{
				  "type": "public-key",
				  "alg": -259
				}
			]

            const publicKeyCredentialRequestOptions = {
				challenge: base64URLStringToBuffer(data.nonce),
				rp: data.rp,
				rpId: data.rp.id,
				user: {
					id: Uint8Array.from(data.user_id), 
					name: `${params.uid}@univ-paris1.fr`,
					displayName: `${params.uid}` 
				},
				pubKeyCredParams: pubkeyTypes,
				// user has 60 seconds to register
				timeout: 60000,
				// leaks data about the user if in direct mode.
				attestation: "none",
				// Use registered credentials
                allowCredentials: data.auths.map(a => ({id: base64URLStringToBuffer(a.credentialID), type: "public-key"})),
			};

            let assertion;
            try {
                // authenticate
                assertion = await navigator.credentials.get({
                    publicKey: publicKeyCredentialRequestOptions
                });
            }
            catch(e) {
                if(e.name === "NotAllowedError") {
                    if(e.message === "CredentialContainer request is not allowed.") {
                        displayText({
                            title: "L'authentification à échoué",
                            desc: "Veuillez réessayer.",
                            show_ask_reload: true,
                        })
                        // There is a firefox bug where if you have your
                        // console opened when you try to call this, it
                        // fails
                        console.info("If the authentication crashed and you had your firefox console open when you tried to login, please close it and try again, as it may be due to a firefox bug. You can ignore this message otherwise.");
                    }
                    else {
                        displayText({
                            title: "L'authentification à échoué",
                            desc: "Vous avez refusé la demande.",
                            show_ask_reload: true,
                        })
                    }
                }
                return;
            }

            if(assertion === undefined) {
                displayText({
                    title: "L'authentification à échoué",
                    desc: "Veuillez réessayer.",
                    show_ask_reload: true,
                })
                return;
            }

            const res = await fetch(`${params.apiUrl}users/${params.uid}/webauthn/login/${params.userHash}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    response: SerializePKC(assertion),
                    credID: assertion.id
                })
            });

            const verifdata = await res.json();

            // Success response
            if(res.status - (res.status % 100) === 200) {
                // prevent double "token" field
                document.querySelector("#token").remove();
                document.querySelector("#wa_token").value = verifdata.token;
                document.querySelector("#fm1").submit();
            }
            // failed
            else {
                if(typeof verifdata.message === "object") {
                    displayText({
                        title: "L'authentification à échoué",
                        desc: verifdata.message.title,
                        extended: verifdata.message.desc,

                        // api outputs html in this case
                        _raw_html: true,
                        // soft-prevent retrying
                        show_try_another: (!verifdata.message.unforgivable) ?? true,
                    })
                }
            }
        });
    }

    function computeChoices(params, methods_and_transports) {
        let choices = []
        $.each(methods, function (method, opts) {

            var real_methods = (opts.real_methods || [method]).filter(function (method_) {
                return (methods_and_transports.methods[method_] || {}).active
            })
            if (real_methods.length === 0) return;
            var params = methods_and_transports.methods[real_methods[0]];

            (params.transports.length ? params.transports : ['']).forEach(function (transport) {
                //if (transport !== '') return;
                var transport_text = transport && methods_and_transports.transports[transport];
                if (opts.label[transport]) {
                    var text = opts.label[transport].replace('%TRANSPORT%', transport_text)
                    choices.push({ 
                        method: method, 
                        real_methods: real_methods, 
                        transport: transport, 
                        transport_text: transport_text, 
                        text: text,
                        override_icon: opts.override_icon
                    })
                } else {
                    console.error("weird transport", transport, "for (pseudo) method", method)
                }
            })
        })
        return choices
    }

    function server_log(vals) {
        fetch('log?' + new URLSearchParams(vals))
    }

    function displayChoices(params, user_params) {
        let choices = computeChoices(params, user_params)
        if (choices.length === 0) {
            show('no-choices');
            try { server_log({ warn: "no-choices", uid: params.uid, service: new URLSearchParams(location.search).get("service") }); } catch (e) {}
            return;
        }
        $("#methodChoices").empty().append(choices.map(function (choice) {
            var button = $("<a class='large'>").click(function () {
                clear_errors();
                activate_method(params, choice, {});
                return false;
            })
            button.append($("<span></span>").text(choice.text))
            button.append($("<img>", { src: "images/liste-" + (choice.override_icon || choice.transport || choice.method) + ".svg" } ))
            return $("<li></li>").append(button)
        }))
        const last_send_message = user_params.last_send_message || {}
        if (!last_send_message.auto || last_send_message.verified || (Date.now() - last_send_message.time) > 4 /* hours */ * 60 * 60 * 1000) {
            // use first by default
            activate_method(params, choices[0], { auto: true })
        }
    }

    function submitCodeRequest(params, chosen, opts) {
        $.ajax({
            type: 'POST',
            url: params.apiUrl + '/users/'+ params.uid +'/methods/' + chosen.method + '/transports/' + chosen.transport + '/' + params.userHash + (opts.auto ? '?auto' : '')
        }).done(function(data) {
            if (data.code !== "Ok") {
                alert("Erreur, veuillez réessayer ultérieurement");
                show('choices');
                console.log("Something is broken : ", data);
            } else {
                console.log(chosen)
                $('#code_label').html(chosen.method === 'push' ? 
                    "Une notification a été envoyée sur votre portable " + chosen.transport_text + ".<br>En attente de son acceptation." : chosen.transport === 'mail' ? 
                    "Un code a été envoyé sur votre mél " + chosen.transport_text + ",<br>saisissez le ici pour vous connecter." : 
                    "Un code a été envoyé au " + chosen.transport_text + ",<br>saisissez le ici pour vous connecter.");
            }
        });
    }
    
    function initializeSocket(params) {
        var socket = io.connect(params.apiUrl, {
            reconnect: true, 
            path: "/sockets", 
            query: 'uid=' + params.uid + '&hash=' + params.userHash + '&app=cas'
        });
        socket.on('connect', function () {
        });          
        socket.on('userAuth', function (data) {
            if (data.code == "Ok") {
                $('#token').val(data.otp);
                $('#fm1').submit();
            }
        });
    }

    function start(params) {
        try { 
            // remove ticket from url for reload/navigation
            window.history.replaceState({}, null, location.href.replace(/[?&]ticket=.*/, '').replace(/[&?]auth_checked$/, ''))
        } catch (e) {}

        getUserOtpMethods(params);
    }

    start(<%- JSON.stringify(params) %>)
</script>

</body>
</html>
